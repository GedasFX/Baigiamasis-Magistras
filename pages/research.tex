\section{Research}

\TODO{Redo the validation sections into 1) security requirements, 2) security requirement compliance by eID provider, 3) security requirement compliance by developers}

\subsection{System architecture}

\subsubsection{System overview}

\begin{figure}
  \centering
  \includegraphics[scale=0.65]{architecture/initial.png}
  \caption{Initial system architecture}
  \label{fig:sys-highlevel}
\end{figure}


\paragraph{Initial state}

In figure \ref{fig:sys-highlevel} we see a high-level overview of a system we are trying to integrate eID authentication. This system consists of the following components:

\begin{enumerate}
  \item AuthServer - the company's SSO; acts as a central authority for identity. Issued OIDC id tokens, which contain user ID, their roles, and claims.
  \item SuperApp - a resource server with access control enabled. It uses id tokens issued by AuthServer and verifies them using asymmetric cryptography.
  \item User store - a data store containing user login information - usernames, password hashes, other PII.
  \item Actor - a physical person accessing the resources in the system.
\end{enumerate}

\paragraph{Desired state}

The company wishes to implement eID authentication. Since the authentication is not done locally but is delegated to some remote service or device, the protocol can be treated as an external federated sign-in. Frameworks such as ASP.NET Identity have special helpful tools to handle external identity providers.

With the inclusion of an external eID provider, we can see the new system architecture in figure \ref{fig:sys-highlevel-witheid}.

\begin{figure}
  \centering
  \includegraphics[scale=0.65]{architecture/witheid.png}
  \caption{System architecture after the inclusion of an eID provider}
  \label{fig:sys-highlevel-witheid}
\end{figure}

We can see two significant additions:

\begin{enumerate}
  \item eID provider - a gateway to obtain someone's eID. It can be any eID source like Dokobit, TARA, Smart-ID, ID card.
  \item Remote key store - it is a storage for unique identifiers provided by the eID provider.
\end{enumerate}

The primary purpose of the remote key store is to link the user ID used in the internal system with the unique identifier provided by the eID provider. Because the unique identifier can change or the same physical person can have multiple eIDs \cite{eidas-saml}, it is required to allow numerous eIDs to map to a single internal ID.

The key store is represented with the addition of a red lock. Depending on the country, the data stored there may be subject to strict privacy regulations. Companies should consider implementing strict access control for this part of the infrastructure.

\paragraph{Final state}

The end goal for the scope of this thesis is to implement three eID providers into the architecture. For normal companies, it would make sense to implement multiple in case they would like to get more coverage. Additionally, they could register non eID providers, such as Google or Microsoft social logins. The final high-level overview of the system can be seen in figure \ref{fig:sys-highlevel-final}.

\begin{figure}
  \centering
  \includegraphics[scale=0.65]{architecture/final.png}
  \caption{System architecture after the inclusion of all eID providers in scope}
  \label{fig:sys-highlevel-final}
\end{figure}

\subsubsection{Process overview}

For validation of the architecture, we will consider two use cases.

The first one (see figure \ref{fig:sysprocess-a}) is concerned about accessing a protected resource with a token issued by the AuthServer. This use case validates the base state of the system.

The second use case (see figure \ref{fig:sysprocess-b}) is also concerned about accessing a protected resource, but only those, who authenticate with a higher level of assurance, like eID, can access it. This use case validates the successful implementation of eID authentication and access control.

\begin{figure}
  \centering
  \begin{sequencediagram}
    \newthread{A}{Actor}{}
    \newinst[3]{B}{AuthServer}{}
    \newinst[1]{C}{SuperApp}{}

    \begin{call}{A}{accessProtected()}{C}{401 Unauthorized}\end{call}

    \begin{call}{A}{authWithPassword()}{B}{Auth token}\end{call}
    \begin{call}{A}{accessProtected()}{C}{Data}\end{call}
    \begin{call}{A}{accessReallyProtected()}{C}{403 Forbidden}\end{call}
  \end{sequencediagram}
  \caption{System behavior when authenticated with a username + password scheme}
  \label{fig:sysprocess-a}
\end{figure}

\begin{figure}
  \centering
  \begin{sequencediagram}
    \newthread{A}{Actor}{}
    \newinst[2]{B}{AuthServer}{}
    \newinst[1]{C}{SuperApp}{}

    \begin{call}{A}{accessProtected()}{C}{401 Unauthorized}\end{call}

    \begin{call}{A}{authWithEid()}{B}{Auth token}\end{call}
    \begin{call}{A}{accessProtected()}{C}{Data}\end{call}
    \begin{call}{A}{accessReallyProtected()}{C}{Very Secret Data}\end{call}
  \end{sequencediagram}
  \caption{System behavior when authenticated with an eID scheme}
  \label{fig:sysprocess-b}
\end{figure}

\subsubsection{Linking eID to an internal user ID}

There will be a need to uniquely link an identity to an internal account in the company SSO. The security requirement, in this case, is not to allow other users to access the same account. For this goal, companies must use one or more person-identifying properties.

When using a passport as a reference, it has the following identifiers: (issuer) country code, document number, surname, given name, personal code, citizenship, date of birth, date of issue, date of expiry, and authority. In these cases, it is easy to use the personal code for identifying a person as it is unlikely to change - people change names, documents expire; authorities and date of birth do not narrow it down nearly enough.

Implementers will hit a roadblock when checking a passport of Ireland - additionally, it has a place of birth but, more importantly, no personal identification code. In this case, the next best unique identifier would be to use the document number and update the account with a new number when the document eventually expires and is replaced.

In the world of digital identity, the eIDAS node network must provide a unique identifier for all requests \cite{eidas-saml}. Having a standardized way of obtaining an identifier is good news. All countries who wish to connect to the eIDAS network would have to expose some code to identify a person uniquely, removing the burden from the software architects to analyze what identifier they should use.

In the eIDAS node network, the unique identifier remains "unchanged for the lifetime of the account" \cite{eidas-saml}. Unfortunately, it does not mean that identifiers cannot change; the account associated with that identifier cannot change. If an identifier were to change when "the user's digital identity is replaced or repaired," relying parties should treat the newly obtained identifier as a completely new identity.

\paragraph{eIDAS Unique Identifier Structure} In eIDAS SAML Attribute Profile, an identifier code is defined as:
\begin{enumerate}
  \item The first part is the Nationality Code of the identifier. This is one of the ISO 3166-1 alpha-2 codes, followed by a slash ("/")).
  \item The second part is the Nationality Code of the destination country or international organization. This is one of the ISO 3166-1 alpha-2 codes, followed by a slash ("/").
  \item The third part is a combination of readable characters. This uniquely identifies the identity asserted in the country of origin but does not necessarily reveal any discernible correspondence with the subject's actual identifier (for example, username, fiscal number etc).
\end{enumerate}

Example: ES/AT/02635542Y (Spanish eIDNumber for an Austrian SP).

\paragraph{Summary} Using eIDAS Unique Identifier structure as a base, we can see that it is enough to uniquely identify a digital identity in eIDAS with the country of origin, country of destination, and a set of characters to identify that person in the origin country. The destination country will always be the same in our company's case. To uniquely identify a person, we will only need its origin country and a unique identifier a member state must provide.

For this thesis, identifiers will be marked as "{\{ISO 3166-1 alpha-2\}}/{\{Code provided by country\}}". Unique identifier examples: EE/38001085718, LT/49003111045, SE/870314-2391.

\subsubsection{Privacy Policy}

The company wishing to implement eID authentication will have to deal with personal information as described by GDPR \cite{eulaw-gdpr}. Before going live with an eID solution, companies must first consult a legal professional for advice.

A privacy policy is a legal document and is way outside of the scope of a technical implementation thesis. However, it is still important to understand the basics. For this goal, two privacy policies will be analyzed: Web eID \cite{legal-webeid-privacypolicy} and Dokobit \cite{legal-dokobit-privacypolicy}.

From the cursory analysis of the two policies, there are three fundamental aspects our company needs to address: what data is processed, with whom the company shares the data, and what is the retention policy.

Based on the privacy policies of Web eID and Dokobit, we constructed a rudimentary privacy policy for the use of the test application environment. A copy of the text can be found in the thesis' appendices.

Further research can be done to outline better the GDPR requirements needed to process a person's eID.

\subsection{Weaknesses in the architecture}

All systems come with points of compromise. It is best to be aware of these weak points and harden against them early on rather than after a cyber incident. The weaknesses can be grouped into two parts: eID provider dependent and local.

\paragraph{eID provider dependant weaknesses}

These threats come from one common issue: trusting an eID service provider when a relying party should not have. There are four primary causes:

\begin{enumerate}
  \item relying party trusts an input from an insecure channel;
  \item relying party does not perform the necessary validation;
  \item weakness in the architecture of transport protocol;
  \item eID provider itself gets compromised;
\end{enumerate}

These points will be addressed on a case-by-case basis for each of the eID providers in the study.

\paragraph{Local weaknesses}

In figure \ref{fig:sys-highlevel-witheid}, four components are not linked to a particular eID: AuthServer, SuperApp, application store, user store, and remote key store. We can identify weaknesses for those parts here. Each weakness was analyzed through the lens of CIA security analysis.


\subsubsection{SuperApp}

These two assets have similar weaknesses, with the only difference being the way users authenticate themselves. More in-depth analysis on authentication for the AuthServer can be seen on the

\paragraph{[CI] Users can see and or edit data normally forbidden to access} This issue is usually created by one of two causes:

\begin{enumerate}
  \item access control measures are disabled or do not protect resources;
  \item OIDC token validation is disabled or misconfigured;
\end{enumerate}

The first cause has a trivial fix - developers have likely forgotten to enable the data access guard on the endpoint. It is unlikely that all authorization rules break.

In the case of the second cause, some corners were likely cut in the ID token validation process. When validating a token, the process has to match the one described in the OIDC spec \cite{oidc} exactly. This process consists of three major parts:

\begin{enumerate}
  \item check if the token's crypto algorithm is as expected;
  \item validate token signature;
  \item validate claims - issuer, audience, timestamp, nonce;
\end{enumerate}

Developers usually need not worry about the process, as most frameworks have adopted the OpenID Connect protocol or have well-maintained libraries.

\paragraph{[A] Service becomes unavailable} This threat is caused by one of the following:

\begin{enumerate}
  \item server is offline or overloaded;
  \item OIDC token validation is misconfigured to have an incorrect authority;
\end{enumerate}

The first case is a common availability issue, meaning the server is suffering a denial of service attack. We will not cover the mitigation of this form of availability threat in the scope of the thesis.

A likely cause for this issue is the manually configured OIDC properties on the relying party. If possible, developers should never configure the properties manually and use the well-known metadata endpoint instead. A metadata endpoint usually looks like this - \url{https://auth.mycompany.org/.well-known/openid-configuration}.


\subsubsection{AuthServer}

All of the points that apply to SuperApp also apply to AuthServer. However, there is a critical use case that is worth mentioning explicitly.

\paragraph{[CI] Users can see used eID schemes and add new ones with unsafe sign-in}

As per requirements, users must assign multiple identity providers to their accounts. When adding a new external scheme, the currently signed-in user must have the same privilege level as the scheme they are trying to add. This countermeasure is for the event an adversary gains access to their account; they wouldn't be able to elevate their privileges by adding their eID scheme and signing in with it.

With this requirement in place, registration with an email and password becomes less valuable, as those accounts could never add an eID afterward. An exception to this rule can occur if a user has no eID schemes registered.

This problem is solved by having a company policy to verify the user's first added eID manually. Without this verification, an adversary can register a new account with their real eID and access the data anyway.

\subsubsection{Data stores}

All three data stores have the exact issues between them. For the sake of brevity, they will be grouped under the umbrella of \textit{data store}.

\paragraph{[CI] Users have a less secure way of accessing the data store}

The system is as secure as its weakest link. If users have direct access to the database while bypassing the eID authentication check, the security and assurance guarantees are worthless.

If there are alternative ways of accessing the database, companies must implement proper access rules that would be as secure as the one's eIDs provide. How that can be achieved depends on what data storage option is being used. The best option would be to close down external access to the data stores completely.

\paragraph{[CI] Man-in-the-middle attacks} While uncommon, some data stores are vulnerable to MitM attacks \cite{sql-server-auth-mitm}. Although the best course of action would be to move the data storage server away from the general internet and make it accessible only on the local network or VPN, that is not always enough. For maximum security, companies must implement the recommended MitM prevention techniques \cite{sql-server-enable-tls}.

\paragraph{[A] Data is destroyed or lost}

Ransomware attacks and accidental database corruptions can happen, so offline remote backups are a must.

One must not forget to satisfy the requirement of not allowing for easier access to data even here. These backups must be protected from unauthorized access.

One approach to solving this would be to use encryption; keys should only be available after authenticating with an eID scheme. One equally secure alternative would be to use something like the encryption and decryption functionality of Estonia's ID cards.

\subsection{Case Study: Dokobit}

\subsubsection{About}

Dokobit \cite{dokobit}, trademark and subsidiary of Estina \cite{euipo-dokobit}, offers two products: Document Signing Portal and API solutions.

The first product, the Document Signing Portal, was released in 2014 \cite{dokobit-aboutus}. The primary purpose of this solution is to allow users to upload documents and digitally sign them online.

Estina has acquired the DigiDoc portal (\url{https://digidoc.ee}) from SK ID Solutions in 2016 \cite{sk-digidocacquired} which had the exact purpose. This portal should not be confused with the similarly named DigiDoc4 client Estonians commonly use to sign documents \cite{ria-idee}.

The second product, API solutions, targets businesses in a variety of scopes: signature collection, signing, identification, sealing, and TSP monitoring \cite{dokobit}. In the thesis, we will only consider the Identification service.

Dokobit's Identification service allows Lithuanian, Latvian, Estonian, Finnish, Norwegian, Icelandic, Polish, Belgian, Portuguese, Spanish, and Italian \cite{dokobit} users to authenticate themselves with their countries' scheme.

The company has received ISO/IEC 27001:2013 certification \cite{dokobit-certification} and in 2020 was included in the EU Trusted Service List \cite{eu-trustservices, dokobit-aboutus}, thus it becoming a Qualified Trust Service Provider.

In 2021, the Norwegian electronic identity solutions provider company Signicat AS acquired UAB Dokobit.

\subsubsection{Dokobit Identification Service}

Identification service supports two distinct data flows: Gateway and API. The core difference between them is that the Gateway uses a prebuilt UI on their server. In contrast, the API requires the companies to develop their UI and have their server communicate with Dokobit servers instead. This difference only affects the user experience.

The main advantage of Identity Gateway over Identity API is the added brand trust. A study finds that users "associate higher security feelings with a higher level of brand trust" \cite{ha2004factors}. If an organization has not matured yet as a brand (such as a recent startup), it will make more sense for them to choose Identity Gateway over API. On the contrary, if they are a large, highly trusted organization, such as a bank, it would make more sense to use Identity API and have all user interactions happen on the same domain.

For this thesis, we will only analyze the Identity Gateway in depth.

\paragraph{Embed or Redirect}

Identity Gateway comes in two primary user flows: embedded and redirect-based.

In embedded flow, users could stay on the website, authenticate in a pop-up modal, and update the website view accordingly after finishing the authentication process. Embedded flow has the advantage of not requiring the users to leave the website, which is helpful to preserve user data in complex forms.

In redirect-based flow, users are sent to an external website, perform authentication, and redirect to the company website, in a flow similar to OAuth2.

Ultimately, experts consider the embedded flow to be the weaker of the two methods \cite{auth0-universal-vs-embedded} for two main reasons:

\begin{enumerate}
  \item Cross-origin requests are inherently more dangerous, allowing for MitM and CSRF attacks;
  \item The client application, even when embedded, receives full client credentials, which adds another point of compromise in the form of XSS;
\end{enumerate}

When using federated sign-in for Native Apps, "best current practice requires that native apps MUST NOT use embedded user-agents to perform authorization requests" \cite{rfc8252}. This practice means that companies who have a mobile app or would consider having one in the future mustn't use Embedded flow.

\subsubsection{Data Flow}

This section will analyze Dokobit Identity Gateway, redirect-based user flow, the general overview of which can be seen in figure \ref{fig:dokobit-identitygw-redirect}. We can group the authentication process into three parts: establishing a session with Dokobit, user authentication with an eID provider, and user information retrieval.

\begin{figure}
  \centering
  \begin{sequencediagram}
    \newthread{A}{Actor}{}
    \newinst[2]{B}{AuthServer}{}

    \newinst[1]{C}{IDGW Backend}{}
    \newinst[1]{D}{IDGW Frontend}{}

    \begin{call}{A}{1. authenticate()}{B}{Session}
      \begin{call}{B}{2. POST /api/authentication/create}{C}{session\_token}\end{call}
      \begin{call}{B}{3. HTTP 302 Redirect}{D}{HTTP 302 Redirect}
        \begin{call}{D}{4. renderedAuthForm()}{A}{Credentials}\end{call}
      \end{call}

      \begin{call}{B}{5. GET /api/authentication/\{session\_token\}/status}{C}{User data}\end{call}
    \end{call}
  \end{sequencediagram}
  \caption{Dokobit Identity Gateway - Redirect-based user flow \cite{dokobit-idgw-docs}}
  \label{fig:dokobit-identitygw-redirect}
\end{figure}

\paragraph{Establishing a session with Dokobit}

When a user requests to authenticate, the company's back-end systems' first step is to establish a session with Dokobit Identity Gateway. To do this, a {POST} request must be made to the {/api/authenticate/create} endpoint. This response will contain the session identifier and the redirect URL. Users will have to go there to interface with their eID providers.

Sample HTTP request data can be seen in listing \ref{lst:dokobit-challenge-http}.

\begin{lstlisting}[caption={Handling Dokobit session creation}, label={lst:dokobit-challenge-http}]
  Request:
  POST https://id-sandbox.dokobit.com/api/authentication/create?access_token=YOUR_ACCESS_TOKEN
  {
      'return_url': 'https://id-sandbox.dokobit.com/example/success.php'
  }
  
  Response:
  {
    "status": "ok",
    "session_token": "02f922c9917231ea8acbbbcf63796924af548c801d75772f2b1701b413462c61",
    "url": "https://id-sandbox.dokobit.com/auth/02f922c9917231ea8acbbbcf63796924af548c801d75772f2b1701b413462c61",
    "expires_in": 3600
  }
\end{lstlisting}

\paragraph{User authentication with an eID provider}

After the back-end successfully creates a session, they must redirect the user to the received endpoint. An easy way to accomplish that is to respond to the initial authentication request with HTTP status 302 - Found.

Most of the heavy lifting with authentication is delegated to this step and handled by Dokobit. The company's back-end systems should wait for the user to return after authenticating.

\paragraph{User information retrieval}

After the user returns after successful authentication, the back-end servers should make a {GET} request to {/api/authentication/session\_token/status} endpoint. The company can securely receive the user information via a backchannel.

Sample HTTP request data can be seen in listing \ref{lst:dokobit-handleremote-http}.

\begin{lstlisting}[caption={Handling Dokobit session creation}, label={lst:dokobit-handleremote-http}]
  Request:
  GET https://id-sandbox.dokobit.com/api/authentication/SESSION_TOKEN/status?access_token=YOUR_ACCESS_TOKEN
  
  Response:
  {
      "status": "ok",
      "certificate": { ... },
      "code": "30303039914",
      "country_code": "lt",
      "name": "DEMO",
      "surname": "SMART-ID",
      "authentication_method": "smartid",
      "date_authenticated": "2019-05-06T12:15:34+03:00"
  }
\end{lstlisting}

\subsubsection{Trust Anchor}

Dokobit assumes the role of being the trust anchor. This means that it also acts as a single point of failure. Should Dokobit become compromised, all applications using Dokobit will become susceptible to impersonation. On the flip side, there is only one system company developers need to implement, meaning that it would be harder for adversaries to break into the system via external means.

Companies should consider the risks when using a provider capable of dictating who the person is, as no integrity checks are supported in the protocol.

\subsubsection{Pricing}

Dokobit is a commercial product, and therefore it has associated usage costs. In 2022, these costs are as seen in the table \ref{tab:dokobit-pricing}.

\begin{table}[h]
  \centering
  \caption{Dokobit Identity Gateway pricing 2022}
  \begin{tabular}{| l | l | l | l |}
    \hline
    \bf{Plan} & \bf{Number of transactions} & \bf{Monthly fee} & \bf{Price per extra transaction} \\
    \hline
    1         & 700                         & 50 €             & 0,071 €                          \\
    \hline
    2         & 1 600                       & 100 €            & 0,063 €                          \\
    \hline
    3         & 5 000                       & 250 €            & 0,050 €                          \\
    \hline
    4         & 12 000                      & 500 €            & 0,042 €                          \\
    \hline
  \end{tabular}
  \label{tab:dokobit-pricing}
\end{table}

Each pricing tier includes a specific number of transactions and adds a cost for each transaction exceeding it. For example, if the total amount of transactions is 200, the price will still be 50 €, as the number of transactions hasn't reached 700.

Assuming the company's users authenticate around 25 times per month, the monthly user price will be in the ballpark of 1-2 €.

\subsubsection{Security Analysis}

\paragraph{Actors}

The actors in the figure \ref{fig:eid-auth-flow-seq} assume the roles of the following: QSCD Interface - Dokobit Identity Gateway; QSCD - eID solutions registered on Dokobit.

In the case of Dokobit Identity Gateway, developers should not be concerned about the QSDC used, as the QSCD interface - Dokobit will provide the user's identity in a standardized form.

\paragraph{Communication channel}

The Dokobit identity gateway uses a secure communication channel, encrypted end-to-end using HTTPS.

\paragraph{Validation requiements}

Unlike eeID and Web eID, Dokobit does not provide validation requirements documentation, so the relying party and developers must be aware of protecting themselves from common authentication attacks.

Because the idea behind authentication is similar inflow to Oauth2, the thesis will use the current security best practices document \cite{ietf-oauth-security-topics-19} and assess which measures developers should be aware of and which ones have been addressed by Dokobit. A detailed explanation of each attack can be found on the IETF document.

Dokobit issues client secrets - API tokens for creating sessions and obtaining user information after the authentication.

\subparagraph{Replay attacks}

\begin{itemize}
  \item Identity Gateway will reject the second GET request with the session token.
\end{itemize}

The developer does not have to implement state management to verify that a given session token was used only once. Mitigation measures are sufficient.

\subparagraph{Insufficient Redirect URI Validation}

\begin{itemize}
  \item The adversary does not have any agency over redirect URI after authentication, as the {authorize} endpoint does not have any query parameters.
  \item The redirect\_url parameter when sending the initial request outlined in step 3 of the sequence diagram cannot be longer than 255 ASCII characters.
  \item The redirect URL is never validated on the Dokobit servers, as it was never registered as a client. Each redirect URL is generated for one-time use.
\end{itemize}

Adversaries cannot influence the redirect URI. Mitigation measures are sufficient.

\subparagraph{Credential Leakage via Referrer Headers}

\begin{itemize}
  \item Dokobit Identity Gateway does not include third-party resources (javascript, image, or other); therefore, it cannot leak the session token.
  \item The company is required not to have any third-party resources on the authentication and redirect pages.
  \item The client is using a secret API key, rendering it impossible to obtain private information without its use.
\end{itemize}

Dokobit does not leak credentials via Referrer Headers, and the developers should not embed third-party resources in the critical authentication pages. Mitigation measures are sufficient.

\subparagraph{Credential Leakage via Browser History}

\begin{itemize}
  \item Session tokens are stored in browser history; however, they are single-use only and are immune to replay attacks.
  \item User personal information details are never exposed to the client.
\end{itemize}

The only thing adversaries could extract from the browser history is a used-up session token, which does not provide much value. Mitigation measures are sufficient.

\subparagraph{Session Token Injection and Cross-Site Request Forgery}

Adversaries would perform the injection and CSRF attacks identically.

\begin{itemize}
  \item The protocol does not protect against session token injection attacks.
  \item The protocol also adds more attack surfaces by issuing the session token before the user signs in, allowing the adversary to obtain or inject it before and after the user performs authentication.
  \item It is possible to mitigate adversaries stealing a victim's session.
  \item \textbf{It is impossible to mitigate adversaries injecting their session} (phishing).
\end{itemize}

Identity Gateway protocol does not have security measures built-in against session token injection or CSRF attacks. It is possible to prevent adversaries from being able to redeem the victim's session. However, there is \textbf{no possible way to prevent adversaries from injecting their Dokobit session}.

From the attacker's point of view, they can exploit this vulnerability by performing these steps \cite{video-exploitdokobit}:

\begin{enumerate}
  \item Establish session with identity server and Dokobit;
  \item Trick the user into opening the link issued by Dokobit;
  \item After the user authenticates, but before gets redirected, reload the page;
  \item If an adversary managed to do it in time, they receive that person's access;
\end{enumerate}

The only way to mitigate this attack for the user will be to make the authentication server invalidate the authenticated session if a request presents the same session\_token. Thankfully, it is easy to detect if the server has consumed the session token already, as Dokobit would reject additional requests, as described in replay attack mitigation.

Mitigation measures are \textbf{weak}, and developers should be ready to implement authentication session revocation.

\subparagraph{Client Impersonating Resource Owner}

\begin{itemize}
  \item Dokobit does not allow users to choose their id or secret.
\end{itemize}

Dokobit made it impossible to perform this attack. Mitigation measures are sufficient.

\subparagraph{Clickjacking}

\begin{itemize}
  \item Dokobit auth page does not use Content-Security-Policy, however it does use header X-Frame-Option: {SAMEORIGIN}.
  \item Framebusting \cite{RYDSTEDT2010BUSTI} techniques were not discovered.
\end{itemize}

Mitigation measures are sufficient on modern browsers.

\subsubsection{Discovered weaknesses}

When analyzing and implementing the protocol, two weaknesses were discovered that developers should be aware of and mitigate.

\paragraph{Session binding}


The Dokobit Identity Gateway protocol is simple and resilient to most forms of attacks out of the box. However, developers should make sure to enforce session binding. Adversaries can perform this attack by going through the following steps:

\begin{enumerate}
  \item Adversary establishes an authentication session with the server, and by extension, Dokobit. They receive a Dokobit session\_token.
  \item Victim establishes an authentication session with authentication session.
  \item Adversary tricks the user into using their session or injects their session token by other means.
  \item Victim authenticates on Dokobit with adversary's session token.
  \item Adversary finishes the session and successfully impersonates the victim.
\end{enumerate}

Developers can mitigate this session token injection and CSRF attack by binding the Dokobit session to the browsing session. When the user returns from Dokobit Identity Gateway, the return URL will have the session token attached in the path. If the authentication server can verify that the same browser has sent the session token and created the session, it would be possible to eliminate this attack.

It is possible to eliminate this attack using encrypted cookies with the session\_token attached (see listings \ref{lst:dokobit-challenge}, \ref{lst:dokobit-handleremote}).

\begin{lstlisting}[caption={Handling Dokobit session creation}, label={lst:dokobit-challenge}]
  protected override async Task HandleChallengeAsync(AuthenticationProperties properties)
  {
      if (string.IsNullOrEmpty(properties.RedirectUri))
          properties.RedirectUri = OriginalPathBase + OriginalPath + Request.QueryString;

      var body = JsonSerializer.Serialize(new { return_url = BuildRedirectUri(Options.CallbackPath) });
      var response = await ExecuteRequestAsync(HttpMethod.Post, "/api/authentication/create", body);

      response.EnsureSuccessStatusCode();
      using var sessionResponse = await JsonDocument.ParseAsync(await response.Content.ReadAsStreamAsync(Context.RequestAborted));
      var root = sessionResponse.RootElement;

      properties.Items["session_token"] = root.GetString("session_token");

      Response.Cookies.Append(Options.StateCookie.Name!, Options.StateDataFormat.Protect(properties), Options.StateCookie.Build(Context, Clock.UtcNow));
      var redirectContext = new RedirectContext<DokobitOptions>(Context, Scheme, Options, properties, root.GetString("url")!);

      await Events.RedirectToAuthorizationEndpoint(redirectContext);
  }
\end{lstlisting}

\begin{lstlisting}[caption={Handling access token creation}, label={lst:dokobit-handleremote}]
  protected override async Task<HandleRequestResult> HandleRemoteAuthenticateAsync()
  {
      var properties = Options.StateDataFormat.Unprotect(Request.Cookies[Options.StateCookie.Name!]);
      if (properties == null)
          return HandleRequestResult.Fail("Invalid state");
  
      var sessionToken = Request.Query["session_token"];
      if (StringValues.IsNullOrEmpty(sessionToken))
          return HandleRequestResult.Fail("Missing session_token", properties);
  
      if (properties.Items["session_token"] != sessionToken)
          return HandleRequestResult.Fail("Unexpected session_token received", properties);
  
      var response = await ExecuteRequestAsync(HttpMethod.Get, $"/api/authentication/{sessionToken}/status");
      response.EnsureSuccessStatusCode();
  
      Response.Cookies.Delete(Options.StateCookie.Name!);
  
      await using var stream = await response.Content.ReadAsStreamAsync(Context.RequestAborted);
      using var user = await JsonDocument.ParseAsync(stream);
  
      var ticket = await CreateTicketAsync(new ClaimsIdentity(ClaimsIssuer), properties, user.RootElement);
      return HandleRequestResult.Success(ticket);
  }
\end{lstlisting}

The first code block (listing \ref{lst:dokobit-challenge}) has three main parts:

\begin{enumerate}
  \item establish a session with Dokobit as described in listing \ref{lst:dokobit-challenge-http};
  \item append an \textbf{encrypted} session cookie which would bind the browser to that specific Dokobit session (this cookie stores the encrypted session\_token);
  \item redirect the user to the authorization endpoint;
\end{enumerate}

After the user authenticates and returns, the next code block gets executed (listing \ref{lst:dokobit-handleremote}). This code performs request validation in addition to retrieving the user data:

\begin{enumerate}
  \item try to decrypt the cookie data - if decryption fails, it was likely tampered with, and the application cannot proceed with the authentication;
  \item try to obtain the session token from query parameters - it should always exist if the request was not tampered with;
  \item verify the session\_token received from cookie and query parameters match - prevents victim's session from being stolen, as adversaries would be unable to redeem it;
  \item redeem the session\_token and receive user data as described in listing \ref{lst:dokobit-handleremote-http};
  \item if redemption was unsuccessful, \textbf{invalidate the previous user session} \cite{video-exploitdokobit};
  \item clean up the used cookies;
  \item issue an access token or a new session for use in the company;
\end{enumerate}

\subsection{Case Study: eeID}

\subsubsection{About}

The Estonian Information System Authority has created TARA - a gateway for public sector services to integrate eID authentication easier and cheaper \cite{tara-business}. At its core, it uses OpenID Connect \cite{tara-technical} protocol to communicate between the service and relying parties.

The Estonian Internet Foundation has then created the eeID service - a clone of TARA, but with the intent to open it up for private businesses at a premium \cite{eeid}.

These services' goal is to use domestic eID providers (ID cards, Mobile-ID, and Smart-ID) and act as a gateway to the eIDAS node network. European Commission regulates this network, allowing for cross-border authentication in a standardized way \cite{eulaw-eidas}.

Cross-border authentication supported by these schemes extends (or will soon extend) to the notified countries \cite{eulaw-eidas-notified}. Currently notified countries (in order of time notified) include Germany, Italy, Croatia, Estonia, Spain, Luxembourg, Belgium, Portugal, Czechia, Netherlands, Slovakia, Latvia, Denmark, Lithuania, Malta, France, and Sweden.

At the time of writing, TARA does not support the eID schemes of the last three - Malta, France, and Sweden. Cross-border authentication is only in the planned state for the eeID service and is currently not supported.

\subsubsection{Data Flow}

The underlying data transfer protocol used by eeID is OpenID Connect code flow \cite{tara-technical, oidc}. A high-level overview of the flow can be seen in figure \ref{fig:oidc-code-flow}. In this flow there are seven main steps:

\begin{figure}
  \centering
  \begin{sequencediagram}
    \newthread{A}{Actor}{}
    \newinst[3]{B}{AuthServer}{}
    \newinst[2]{C}{TARA/eeID}{}

    \begin{call}{A}{1. login()}{B}{3xx Redirect}\end{call}
    \begin{call}{A}{2. authorize()}{C}{Auth Page}\end{call}
    \begin{call}{A}{3. login()}{C}{3xx Redirect + code}\end{call}

    \begin{call}{A}{4. loginCallback()}{B}{Auth token}
      \begin{call}{B}{5. verifyState()}{B}{}\end{call}
      \begin{call}{B}{6. token()}{C}{id\_token}\end{call}
      \begin{call}{B}{7. verifySignature()}{B}{}\end{call}
    \end{call}
  \end{sequencediagram}
  \caption{OIDC code flow used in TARA/eeID}
  \label{fig:oidc-code-flow}
\end{figure}

\begin{enumerate}
  \item Initial login. Preparation for redirect to the eID provider.
  \item Redirection to the eID provider.
  \item Authentication. Users log in with the chosen authentication scheme (ID card, Mobile-ID, Smart-ID, eIDAS).
  \item Redirection back to the Auth server.
  \item Browsing session verification. Cryptographically check if the request came from the same browser. This step is required to protect against CSRF attacks.
  \item Token acquisition. The Auth server exchanges the received code for an identity token containing the user's information.
  \item Signature verification. Verify the authenticity and validity of the received token. \todo{why tho???}
\end{enumerate}

\subsubsection{Trust Anchor}

One of the main advantages of using eeID is the simplicity of integrating multiple sources of eID (ID card, Mobile-ID, Smart-ID, and eIDAS) with a single API. To accommodate this, eeID needs to act as an intermediary service, reading and reprocessing data to create a unified response. With this approach, there are two issues: confidentiality and integrity.

Confidentiality issues occur whenever users do not wish to share their personal information with more parties than absolutely required. For example, if a user wanted to authenticate with Smart-ID, only two parties should be involved: the company user is trying to log in to and SK ID Solutions. With eeID, another entity is added between them who has full access to the data.

Integrity issues are caused by having that full access to data. Should the identity provider or the part issuing identity tokens get compromised, attackers could impersonate anyone.

Companies should keep these risks in mind when integrating the eeID identity provider.

\subsubsection{Pricing}

The operational cost when using the eeID identity provider is nine cents per successful authentication \cite{eeid-pricing}. It is the highest price from all identity providers and does not have tiers. A thousand successful authentications would cost 90 €.

\subsubsection{Security Analysis}

\paragraph{Actors}

The actors in the figure \ref{fig:eid-auth-flow-seq} assume the roles of the following: QSCD Interface - eeID; QSCD - eID solutions registered on eeID.

In the case of eeID, developers should not be concerned about the QSDC used, as the QSCD interface - eeID will provide the user's identity in a standardized form.

\paragraph{Communication channel}

The Dokobit identity gateway uses a secure communication channel, encrypted end-to-end using HTTPS.

\paragraph{Validation requiements}

OpenID Connect specifies three different flows - code, implicit, and hybrid \cite{oidc}. In code flow, all sensitive tokens are handled via backchannel - a secure communications channel where the user client is not involved. The implicit flow is the opposite - a client receives an identity token and sends it to the company's authentication server, which validates the signature. A hybrid flow is a mixture of the two. Security experts consider the code flow to be the safest option of the three \cite{ietf-oauth-security-topics-19}. Coincidentally, it is the only supported flow by TARA and eeID \cite{tara-technical}.

\subparagraph{Replay attacks}

\begin{itemize}
  \item eeID will reject the second POST /token request with the same code.
\end{itemize}

The developer does not have to implement state management to verify that a given session token was used only once. Mitigation measures are sufficient.

\subparagraph{Insufficient Redirect URI Validation}

\begin{itemize}
  \item Changes in the registered OIDC application undergo manual verification by eeID employees.
\end{itemize}

The manual verification process was sufficient to mitigate this attack; impossible to test if countermeasures existed on the client registration interface. Mitigation measures are adequate.
\TODO{Talk about mix up attacks broadly in the architecture topic}
\subparagraph{Credential Leakage via Referrer Headers}

\begin{itemize}
  \item eeID does not include third-party resources (javascript, image, or other); therefore, it cannot leak any query parameters to third parties.
  \item The company is required not to have any third-party resources on the authentication and redirect pages.
  \item The client is using a secret API key, rendering it impossible to obtain private information without its use.
\end{itemize}

The eeID service does not leak credentials via Referrer Headers, and the developers should not embed third-party resources in the critical authentication pages. Mitigation measures are sufficient.

\subparagraph{Credential Leakage via Browser History}

\begin{itemize}
  \item Replay attacks are mitigated against.
  \item Form post response mode is not supported.
\end{itemize}

The only thing adversaries could extract from the browser history is a used-up session token, which does not provide much value. Mitigation measures are sufficient.

\subparagraph{Authorization Code Injection and Cross-Site Request Forgery}

\begin{itemize}
  \item The use of state parameter prevents CSRF, but not code injection attacks. Because the state is not bound to an authorization code, an attacker can perform a high level attack and inject their code to someone else's user agent, or steal someone else's code.
  \item eeID optionally supports the OIDC nonce parameter which fixes the injection attack. When user is initially redirected to the endpoint, a nonce parameter will be bound to the given code response. After the token was received, the RP can check if nonce in received token matches the one in the user agent session. If they are not, a session token was likely injected.
\end{itemize}

Mitigation measures are sufficient.

\subparagraph{Client Impersonating Resource Owner}

\begin{itemize}
  \item eeID does allow users to chose their client id, but is registering applications manually.
\end{itemize}

Issue resolved via operational security. Mitigation measures are sufficient.

\subparagraph{Clickjacking}

\begin{itemize}
  \item Dokobit auth page does not use Content-Security-Policy, however it does use header X-Frame-Option: {DENY}.
  \item Framebusting \cite{RYDSTEDT2010BUSTI} techniques were not discovered.
\end{itemize}

Mitigation measures are sufficient on modern browsers.

\subsubsection{Implementation}

\subsubsection{Discovered Weaknesses}

\paragraph{Incorrect implementation of at\_hash}

In the TARA Technical Specification \cite{tara-technical}, the identity token has at\_hash value that is not according to the OIDC spec \cite{oidc}.

When looking at the id token response, it has a property at\_hash with the value of {X0MVjwrmMQs/IBzfU2osvw==}. This value is supposed to be base64url encoded. Instead, it is a regular base64 string. The Demo REST Client example provided by the same authors \cite{tara-demorest} correctly converts the base64 value into the base64url encoded value, which leads us to believe that there is a mistake in the documentation and or implementation. If it was following the specifications of the TARA documentation and not OIDC spec, it should have no reason to do so.

The eeID service is following the TARA documentation, and because of that, the at\_hash uses base64. An issue arises when the using OpenID Connect libraries (see listing \ref{lst:ms-oidc-at-hash}).

\begin{lstlisting}[caption={Microsoft.IdentityModel.Protocols.OpenIdConnect fails to validate at\_hash}, label={lst:ms-oidc-at-hash}]
  IDX21348: Validating the 'at_hash' failed, see inner exception.
  IDX21300: The hash claim: 'UtsKV8+hA/bB0EE/xR9cCQ==' in the id_token did not validate with against: 'AT-95-VU6Y2LZjrNrVCdhlEaCxG6Gpzt0RsE-Z', algorithm: 'RS256'.
\end{lstlisting}

If we compute the hash manually we see that this is exactly what happens (see listing \ref{lst:athash-manual}). The same transcoding behavior is seen on the TARA Demo Client \cite{tara-demorest}.

\begin{lstlisting}[caption={Verifying at\_hash manually}, label={lst:athash-manual}, language={bash}]
  user@localhost:~$ access_token="AT-95-VU6Y2LZjrNrVCdhlEaCxG6Gpzt0RsE-Z"
  user@localhost:~$ echo -n $access_token | openssl dgst -binary -sha256 | head -c 16 | base64
  UtsKV8+hA/bB0EE/xR9cCQ==
  user@localhost:~$ echo -n $access_token | openssl dgst -binary -sha256 | head -c 16 | base64 | tr '/+' '_-' | tr -d '='
  UtsKV8-hA_bB0EE_xR9cCQ
\end{lstlisting}

The implication of this discovery means that all working clients which use eeID have incorrect OpenID connect implementation. This issue affects only those who use the correct OpenID Connect implementation libraries.

\subsection{Case Study: Web eID}

\subsubsection{About}

Released in the Summer of 2021 \cite{ria-webeid} and having undergone significant changes in January of 2022, this eID framework allows users to authenticate and sign documents using their smart cards.

Functionally this framework is split into three parts: software the user needs to install on their computer, a javascript library that acts as a data intermediary, and the certificate validation library for the back-end.

The software users need to install is similar to the one various countries' governments issue. The significant difference is that this software supports more than one countries' eID solutions. Supported countries include Estonia, Latvia, Lithuania, and Finland \cite{ria-webeid}.

This service is built by the Estonian Information System Authority, responsible for TARA, Estonia's public sector gateway. No publicly available audit certification is available at the time of writing \todo{is this true?}.

\subsubsection{Data Flow}

Figure \ref{fig:web-eid-authentication} displays the high-level overview of the complete flow of data within the Web eID framework. A detailed explanation of the steps can be found on the technical specification page \cite{ria-webeid-systemarchitecture}. Companies implementing the framework should only consider the browser and the server application (steps 1-3 and 13-17).

\begin{figure}
  \centering
  \includegraphics[scale=0.6]{webeid/Web-eID-authentication-communication-diagram}
  \caption{Web eID Authentication flow \cite{ria-webeid-systemarchitecture}}
  \label{fig:web-eid-authentication}
\end{figure}

\subsubsection{Trust Anchor}

Unlike Dokobit and eeID, Web eID does not provide any guarantees about the trustworthiness of a certificate. It is, however, not out of malice and reminds developers by sending the certificate in a field called "unverifiedCertificate" \cite{ria-webeid-source-web-eid-authtoken-validation-java-readme}.

The relying party must verify the certificate and challenge themselves by checking the origin, certificate expiry, trust chain, OCSP response, and the challenge. This validation structure makes the trust anchor technological and highly dependent on the implementation correctness by the developers.

\todo{Discuss how we can never trust developers without proper supervision}

\subsubsection{Pricing}

The Web eID authentication service is free of charge, as the only external validation, OCSP \cite{rfc6960} requests are free to use. When creating digital signatures, the timestamping service may require payment \cite{ria-webeid-source-web-eid-authtoken-validation-java-readme}.

\subsubsection{Security Analysis}

\paragraph{Actors}

The actors in the figure \ref{fig:eid-auth-flow-seq} assume the roles of: QSCD Interface - web-eid.js \cite{ria-webeid-source-web-eid-js}, web-eid-app \cite{ria-webeid-source-web-eid-app}; QSCD - Smart cards of Estonia, Latvia, Lithuania, and Finland \cite{ria-webeid}.

Even though distributed by the same website, id.ee, this interface is separate from the official id.ee software Estonian citizens use to sign and verify documents. "In the future, the final version of Web eID will be added into the ID-software installation package, available for the users the website on www.id.ee" \cite{ria-webeid}. Owners of other countries' smart cards will still have to download the special software from id.ee.

\paragraph{Communication channel}

The Web eID framework uses an insecure channel for communications, so developers must take caution and verify received data when implementing the framework. This channel is susceptible to man-in-the-middle attacks done by the client.

Unlike in the cases of Dokobit and eeID, the risk of impersonation is not transferred to the eID service provider.

\paragraph{Validation requiements}

For each protocol implementation step, developers will have to fulfill certain guarantees before the system goes into production.

\subparagraph{Steps 1-3}

Building the challenge nonce. The goal of these steps is to create the challenge the user will have to sign with their private key. There are a couple of guarantees the application must provide:
\begin{enumerate}
  \item Generated challenge nonce must be between 32 and 96 bytes (inclusive) in length \cite{ria-webeid-source-web-eid-app-authenticate};
  \item "It must be guaranteed that the authentication token is received from the same browser to which the corresponding challenge nonce was issued" \cite{ria-webeid-source-web-eid-authtoken-validation-java-readme}. The framework creators suggest attaching it to the user session.
  \item "Cache must be used for protection against replay attacks by guaranteeing that each authentication token can be used exactly once" \cite{ria-webeid-source-web-eid-authtoken-validation-java-readme}.
  \item "Cookie-based authentication must be protected against cross-site request forgery (CSRF) attacks and extra measures must be taken to secure the cookies by serving them only over HTTPS and setting the HttpOnly, Secure and SameSite attributes" \cite{ria-webeid-source-web-eid-authtoken-validation-java-readme}.
\end{enumerate}

In the implementation example, these measures were addressed by:
\begin{enumerate}
  \item a 64 byte cryptographically secure randomly generated nonce is created (see listing \ref{lst:web-eid-challenge});
  \item challenge nonce is set in the user's session, which adversaries cannot tamper;
  \item the generated nonce is stored into local memory cache for later use; nonce expires after 5 minutes;
  \item an input field is rendered on the page with a unique CSRF validation token, which prevents cross-site request forgery attacks (see listing \ref{lst:web-eid-challenge-ui});
\end{enumerate}

\begin{lstlisting}[caption={Web eID Challenge Endpoint}, label={lst:web-eid-challenge}]
private TimeSpan ChallengeLifetime { get; } = TimeSpan.FromMinutes(5);

private readonly IMemoryCache _cache; // Injected

[HttpGet("challenge")]
public IActionResult GetChallenge()
{
    var nonce = RandomNumberGenerator.GetBytes(64);

    _cache.Set(Convert.ToBase64String(nonce), true, ChallengeLifetime);
    HttpContext.Session.Set("eid.challenge", nonce);

    return Ok(new { nonce });
}
\end{lstlisting}


\begin{lstlisting}[caption={Web eID UI excerpt}, label={lst:web-eid-challenge-ui}, language={html}]
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery _csrf
@{ var csrfToken = _csrf.GetAndStoreTokens(HttpContext); }

<!-- Button used to sign in -->
<a role="button" class="btn btn-secondary" id="webeid-auth-button">Web eID</a>

<input id="csrfToken" type="hidden" value="@csrfToken.RequestToken"/>

<script>
    ...

    const authTokenResponse = await fetch("/signin-id/login", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            "RequestVerificationToken": document.getElementById("csrfToken").value
        },
        body: JSON.stringify(...)
    });

    ...
</script>
\end{lstlisting}

\subparagraph{Steps 13-17}

After the user signs the nonce challenge and sends their certificate, the server must verify its authenticity. The application must perform all of the following before allowing the user to sign in:

\begin{enumerate}
  \item verify the CSRF token from earlier steps \cite{ria-webeid-source-web-eid-authtoken-validation-java-readme};
  \item verify the challenge nonce came from the original user and has not expired, was not consumed;
  \item verify the certificate validity and check if nonce was signed by the associated private key (see below);
  \item issue an authentication token with the fields from the certificate's subject;
\end{enumerate}

In the implementation example, these measures were addressed by:
\begin{enumerate}
  \item the back end endpoint for login is decorated with ValidateAntiForgeryToken Attribute. This attribute instructs the ASP.NET API to ignore requests not containing a CSRF token \cite{msdocs-anti-request-forgery}. A JavaScript application can only access the protected endpoints by providing RequestVerificationToken header (see listing \ref{lst:web-eid-challenge-ui});
  \item the application tries to extract the challenge nonce from the browsing session. The process would succeed if the session cookie were not modified. After the extraction, the application checks the nonce cache to verify if the challenge is still active. Cache hit means the nonce has not expired, and no previous authentication attempt was performed. Remove the challenge nonce from all stores.
  \item The API calls a standalone validation service to verify the nonce and certificate (see below).
  \item Application populates the ASP.NET identity management system with the fields from the certificate: serial number, given name, surname, country. An identity session cookie is sent to the client.
\end{enumerate}

\begin{lstlisting}[caption={Web eID Login Endpoint}, label={lst:web-eid-login}]
[HttpPost("login")]
[ValidateAntiForgeryToken]
public async Task<IActionResult> Login([FromBody] WebIdAuthTokenResponse token)
{
    // Obtain the challenge from session
    if (!HttpContext.Session.TryGetValue(ChallengeNonceKey, out var nonce) && nonce == null)
        return Unauthorized();

    // Check if token was not used before or expired
    var challenge = Convert.ToBase64String(nonce);
    if (!_cache.TryGetValue(challenge, out _))
        return Unauthorized();

    _cache.Remove(challenge);
    HttpContext.Session.Remove(ChallengeNonceKey);

    // Validate the certificate and signed challenge
    var validationResult = await _webEidValidationService.GetResult(new WebEidValidationRequest(token, nonce));
    if (!validationResult.Success)
        return Forbid();

    // Certificate is valid. Sign in the user

    await HttpContext.SignInAsync(BuildUser(new X509Certificate2(Convert.FromBase64String(token.UnverifiedCertificate)).Subject));

    return Ok();
}
\end{lstlisting}

\subparagraph{Certificate and nonce verification}

This step is the most complicated in the entire validation process. To prevent any issues with incorrect implementation, the framework maintainers recommend using their library for validation \cite{ria-webeid-source-web-eid-authtoken-validation-java-readme}. Libraries can come with security vulnerabilities, and developers are reluctant to update their used version; however, it is still more favorable to creating vulnerabilities from misconfiguration \cite{9240619}.

The eu.webeid.security Java package performs most of the certificate validation: expiry, purpose, policy, OCSP \cite{ria-webeid-source-web-eid-authtoken-validation-java-readme}. Developers will only have to configure the CA and host validation. Configuration is handled by providing a set of trusted CA certificates for trust chain verification and the hostname for challenge nonces (see listing \ref{lst:web-eid-java-lib}).

\todo{This library does favor EE cards a lot more, even having hardcoded some Mobile ID policies. Not sure if it is worth mentioning.}

\begin{lstlisting}[caption={Web eID Login Endpoint}, label={lst:web-eid-java-lib}]
public class AuthTokenValidatorService {

  @Bean
  public AuthTokenValidator validator() {
    try {
      return new AuthTokenValidatorBuilder()
        .withSiteOrigin(URI.create(System.getenv("ORIGIN_URL")))
        .withTrustedCertificateAuthorities(loadTrustedCACertificatesFromCerFiles())
        .build();
    } catch (JceException e) {
      throw new RuntimeException("Error building the Web eID auth token validator.", e);
    }
  }

  private X509Certificate[] loadTrustedCACertificatesFromCerFiles() {
    List<X509Certificate> caCertificates = new ArrayList<>();

    try {
      CertificateFactory certFactory = CertificateFactory.getInstance("X.509");

      File[] files = new File("/certs").listFiles((f, n) -> n.endsWith(".cer"));
      if (files != null) {
        for (File file : files) {
          try (InputStream stream = new FileInputStream(file)) {
            X509Certificate caCertificate = (X509Certificate) certFactory.generateCertificate(stream);
            caCertificates.add(caCertificate);
          }
        }
      }
    } catch (CertificateException | IOException e) {
      throw new RuntimeException("Error initializing trusted CA certificates.", e);
    }

    return caCertificates.toArray(new X509Certificate[0]);
  }
}
\end{lstlisting}

The token validation service described in listing \ref{lst:web-eid-java-lib} requires the maintainers to set the origin URL in the form of an environment variable and to populate the folder {/certs} with trusted CA certificates.

Origin URL can be obtained by checking the {window.origin} JavaScript variable in the page containing the sign-in button.

For the CA certificate set, the company can get an up-to-date list of trusted certificates at the EU Trust Services Dashboard \cite{eu-trustservices}. The issue with this list is that it contains all trust certificates for various scopes. In our case, we should limit the search to the extent of QCert for ESig. In the case of Estonia and Lithuania, only three entities are certified to issue certificates for QSCD (see figure \ref{fig:eu-tsp-list}). It is in stark contrast to Spain's 31 \cite{eu-trustservices}. It is possible to further narrow down to only certificate generation services for qualified certificates (CA/QC).

\begin{figure}
  \centering
  \includegraphics[scale=0.54]{webeid/eu-tsp-search}
  \caption{List of EU Trust service providers of Estonia and Lithuania capable of creating qualified certificates for e-signatures}
  \label{fig:eu-tsp-list}
\end{figure}

In the case of Estonia's single TSP, we can see that only 3 CA are currently operational (see figure \ref{fig:eu-tsp-skid}). Unfortunately, there is no standardized way of narrowing down which certificates could be used for authentication.

\begin{figure}
  \centering
  \includegraphics[scale=0.54]{webeid/eu-tsp-skid}
  \caption{List of certificates issued to SK ID Solutions AS for the purposes of Qualified certificate for electronic signature}
  \label{fig:eu-tsp-skid}
\end{figure}

An alternative way to obtain certificates would be to go to the government authority of each country responsible for the distribution of certificates. This action requires prior knowledge of who is responsible for issuing certificates and their purposes.

In Lithuania's case, it is the Ministry of the Interior \cite{eid-lt-ministryofinterior-certificates} who issue two certificates (A and B) every couple of years. As of early 2022, four certificates are active, and all will be added to the trusted CA list.

In Estonia's case, SK ID Solutions manages the CA certificates \cite{eid-ee-skid-certificates}. Of the three certificates found on the EU Trust Services Dashboard, only two are relevant to us, the 2015 and 2018 ones, as the 2016 one has its purpose for use in Smart-ID, which the Web eID framework does not support.

The final list of certificates to support Lithuania and Estonia include four certificates from Lithuania's Ministry of the Interior and two certificates issued by SK ID Solutions for a total of six. It is essential to keep track of these certificates as each one of them can act as a point of compromise and must be monitored in the event they are revoked for security \cite{roca-vulnerability-lessons-learned} or other issues.

\TODO{Discussion: suggest how the certificates are way too challenging to obtain for a casual company and may lead to additional vulnerabilities}
\TODO{Discussion: phishing attacks if the company establishes policy to add certificates if they cannot sign in with their card}

\subparagraph{Exposing the service}

With the certificate validation service configured, it is now required to link it to the Web API. If the company orients around using microservices, this service can be just that. All that the validation service requires is to expose an endpoint that accepts a nonce and a token from the javascript library and returns a validation result.

Companies must take proper measures to protect such service from adversaries as it acts as a fundamental trust anchor. Developers should take steps outlined in assume breach \todo{citation missing} to mitigate the risk of misuse, with the use of TLS and other countermeasures.

\paragraph{Transport protocol}

Researcher Arnis Paršovs published a security analysis of the protocol v1 in October of 2021 \cite{arnis-report-webeid}. Developers behind the Web eID framework acknowledged the weaknesses and addressed them in v2 \cite{ria-webeid-systemarchitecture}, which will be used in the scope of the thesis. At the time of writing, independent researchers and auditors have not yet performed security analysis for this version.

The protocol is two asynchronous JavaScript calls to an API endpoint, which exists on the same website; the user does not need to leave the page. No redirects or third parties are involved; therefore, the analysis of a redirect-based protocol is not applicable in this scenario.

\TODO{Related research about legal person documents?}
\TODO{Complete alternative, using your own issued certificates?}