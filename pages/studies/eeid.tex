\section{Case Study: eeID}

\subsection{About}

The Estonian Information System Authority has created TARA - a gateway for public sector services to integrate eID authentication easier and cheaper \cite{tara-business}. It is heavily inspired by the OpenID Connect \cite{tara-technical} protocol to communicate between the service and relying parties.

The Estonian Internet Foundation has then created the eeID service - a clone of TARA, but with the intent to open it up for private businesses at a premium \cite{eeid}.

These services' goal is to use domestic eID providers (ID cards, Mobile-ID, and Smart-ID) and act as a gateway to the eIDAS node network.

Cross-border authentication supported by these schemes extends (or will soon extend) to the notified countries \cite{eulaw-eidas-notified}. Currently notified countries (in order of time notified) include Germany, Italy, Croatia, Estonia, Spain, Luxembourg, Belgium, Portugal, Czechia, Netherlands, Slovakia, Latvia, Denmark, Lithuania, Malta, France, and Sweden.

At the time of writing, TARA does not support the eID schemes of the last three - Malta, France, and Sweden, and cross-border authentication is only in the planned state for the eeID service and is currently not supported.

\subsection{Data Flow}

The underlying data transfer protocol used by eeID is almost identical to OpenID Connect code flow \cite{tara-technical, oidc}. One irregularity exists between the OIDC spec and TARA, which makes the whole flow non-compliant to the spec \cite{tara-non-oidc-compliant}. Otherwise, the flow is identical. A high-level overview of this flow can be seen in figure \ref{fig:oidc-code-flow}. It consists of seven main steps:

\begin{figure}
  \centering
  \begin{sequencediagram}
    \newthread{A}{Actor}{}
    \newinst[3]{B}{AuthServer}{}
    \newinst[2]{C}{TARA/eeID}{}

    \begin{call}{A}{1. login()}{B}{3xx Redirect}\end{call}
    \begin{call}{A}{2. authorize()}{C}{Auth Page}\end{call}
    \begin{call}{A}{3. login()}{C}{3xx Redirect + code}\end{call}

    \begin{call}{A}{4. loginCallback()}{B}{Auth token}
      \begin{call}{B}{5. verifyState()}{B}{}\end{call}
      \begin{call}{B}{6. token()}{C}{id\_token}\end{call}
      \begin{call}{B}{7. verifySignature()}{B}{}\end{call}
    \end{call}
  \end{sequencediagram}
  \caption{OIDC code flow used in TARA/eeID}
  \label{fig:oidc-code-flow}
\end{figure}

\begin{enumerate}
  \item Initial log-in. Preparation for redirect to the eID provider.
  \item Redirection to the eID provider.
  \item Authentication. Users log in with the chosen authentication scheme (ID card, Mobile-ID, Smart-ID, eIDAS).
  \item Redirection back to the Auth server.
  \item Browsing session verification. Cryptographically check if the request came from the same browser. This step is required to protect against CSRF attacks.
  \item Token acquisition. The Auth server exchanges the received code for an identity token containing the user's information.
  \item Signature verification. Verify the authenticity and validity of the received token. 
\end{enumerate}

\subsection{Trust Anchor}

One of the main advantages of using eeID is the simplicity of integrating multiple sources of eID (ID card, Mobile-ID, Smart-ID, and eIDAS) with a single API. To accommodate this, eeID acts as an intermediary service, reading and reprocessing data to create a normalized response. With this approach, there are two issues: confidentiality and integrity.

Confidentiality issues occur whenever users do not wish to share their personal information with more parties than absolutely required. For example, if a user wants to authenticate with Smart-ID, only two parties should be involved: the company user is trying to log in to (WorkAuth) and the Smart-ID service provider (SK ID Solutions). With the eeID service, another entity is added between them who has full read and write to the data.

Integrity issues are caused by having that full access to data. Should the eeID service get compromised, attackers could impersonate anyone in all services relying on eeID.

Companies should keep these risks in mind when integrating the eeID identity provider.

\subsection{Pricing}

The operational cost when using the eeID identity provider is nine cents per successful authentication \cite{eeid-pricing}. It is the highest price among all identity providers and does not have tiers. A thousand successful authentications would cost WorkAuth 90 â‚¬.

\subsection{Security Analysis}

\paragraph{Actors}

The actors in the figure \ref{fig:eid-auth-flow-seq} assume the roles of the following: QSCD Interface - eeID; QSCD - eID solutions registered on eeID.

In the case of eeID, developers should not be concerned about the QSDC used, as the QSCD interface - eeID will provide the user's identity in a standardized form.

\paragraph{Communication channel}

The Dokobit identity gateway uses a secure communication channel, encrypted end-to-end using HTTPS.

\paragraph{Validation requiements}

OpenID Connect specifies three different flows - code, implicit, and hybrid \cite{oidc}. In code flow, all sensitive tokens are handled via backchannel - a secure communications channel where the user client is not involved. The implicit flow is the opposite - a client receives an identity token and sends it to the company's authentication server, which validates the signature. A hybrid flow is a mixture of the two. Security experts consider the code flow to be the safest option of the three \cite{ietf-oauth-security-topics-19}. Coincidentally, it is the only supported flow by TARA and eeID \cite{tara-technical}.

\subparagraph{Replay attacks}

\begin{itemize}
  \item eeID will reject the second POST /token request with the same code.
\end{itemize}

The developer does not have to implement state management to verify that a given session token was used only once. Mitigation measures are sufficient.

\subparagraph{Insufficient Redirect URI Validation}

\begin{itemize}
  \item Changes in the registered OIDC application undergo manual verification by eeID employees.
\end{itemize}

The manual verification process was sufficient to mitigate this attack; impossible to test if countermeasures existed on the client registration interface. Mitigation measures are adequate.
\TODO{Talk about mix up attacks broadly in the architecture topic}
\subparagraph{Credential Leakage via Referrer Headers}

\begin{itemize}
  \item eeID does not include third-party resources (javascript, image, or other); therefore, it cannot leak any query parameters to third parties.
  \item The company is required not to have any third-party resources on the authentication and redirect pages.
  \item The client is using a secret API key, rendering it impossible to obtain private information without its use.
\end{itemize}

The eeID service does not leak credentials via Referrer Headers, and the developers should not embed third-party resources in the critical authentication pages. Mitigation measures are sufficient.

\subparagraph{Credential Leakage via Browser History}

\begin{itemize}
  \item Replay attacks are mitigated against.
  \item Form post response mode is not supported.
\end{itemize}

The only thing adversaries could extract from the browser history is a used-up session token, which does not provide much value. Mitigation measures are sufficient.

\subparagraph{Authorization Code Injection and Cross-Site Request Forgery}

\begin{itemize}
  \item The use of state parameter prevents CSRF, but not code injection attacks. Because the state is not bound to an authorization code, an attacker can perform a high level attack and inject their code to someone else's user agent, or steal someone else's code.
  \item eeID optionally supports the OIDC nonce parameter which fixes the injection attack. When user is initially redirected to the endpoint, a nonce parameter will be bound to the given code response. After the token was received, the RP can check if nonce in received token matches the one in the user agent session. If they are not, a session token was likely injected.
\end{itemize}

Mitigation measures are sufficient.

\subparagraph{Client Impersonating Resource Owner}

\begin{itemize}
  \item eeID does allow users to chose their client id, but is registering applications manually.
\end{itemize}

Issue resolved via operational security. Mitigation measures are sufficient.

\subparagraph{Clickjacking}

\begin{itemize}
  \item Dokobit auth page does not use Content-Security-Policy, however it does use header X-Frame-Option: {DENY}.
  \item Framebusting \cite{RYDSTEDT2010BUSTI} techniques were not discovered.
\end{itemize}

Mitigation measures are sufficient on modern browsers.

\subsubsection{Integration}

The best way to integrate the eeID service would be to use already existing OpenID Connect implementation options. Cloud hosting giants Amazon Web Services and Microsoft Azure offer an easy way to incorporate an OIDC provider (see figures \ref{fig:addoidc-aws}, \ref{fig:addoidc-azure}). Alternatively, there are many officially certified services and libraries developers can use \cite{oidc-certified}.

This thesis will use Microsoft's official ASP.NET Core library \cite{ms-auth-oidc-src}.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{eeid/addoidc-aws}
  \caption{Adding OpenID Connect provider to Amazon Web Services}
  \label{fig:addoidc-aws}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{eeid/addoidc-azure}
  \caption{Adding OpenID Connect provider to Microsoft Azure}
  \label{fig:addoidc-azure}
\end{figure}

\paragraph{Manual integration} If for any reason use of libraries is not available or acceptable, developers can integrate the OpenID Connect protocol themselves. They do not have to integrate the whole protocol, just the code flow. For reference, we will use the source code from the {.NET} library \cite{ms-auth-oidc-src} and the TARA documentation \cite{tara-technical}. The steps listed will be as seen in figure \ref{fig:oidc-code-flow}.

\subparagraph{Login}

This step is all about user agent session binding and {authorize URL} generation. This is a multipart section so each part will be split into its own paragraph.

For the {authorize} endpoint URL generation is best to look at chapter 4.1 of TARA documentation \cite{tara-technical}. There are, however, some notes to keep in mind when integrating the eeID service:

\begin{itemize}
  \item \url{https://auth.eeid.ee/oidc/.well-known/openid-configuration} contains all of the necessary information to realize which endpoints to use and what values are currently accepted.
  \item \url{https://test-auth.eeid.ee/oidc/.well-known/openid-configuration} contains the configuration for the eeID test environment.
  \item {response\_type}: the only flow supported by TARA/eeID is code flow, so this value can only be code.
  \item {nonce}: although not required, it protects against authorization code injection attacks and should be used whenever possible \cite{ietf-oauth-security-topics-19}.
  \item {ui\_locales, acr\_values}: these fields are non-standard, and most if not all libraries will not support them out of the box. For most use cases, these values can be left empty.
  \item {code\_challenge, code\_verifier}: Proof Key for Code Exchange (PKCE) is not supported, {nonce} should be used in its place.
  \item {response\_mode}: not supported, therefore only response mode of {query} can be used.
  \item {nonce, state}: both nonce and state have the exact behavior (see Discovered Weaknesses for more information).
\end{itemize}

With this information, we can extrapolate a working {authorize} request (see listing \ref{lst:eeid-authorize}).

\begin{lstlisting}[caption={The eeID service authorize endpoint request}, label={lst:eeid-authorize}]
  GET https://test-auth.eeid.ee/oidc/authorize?

  client_id=oidc-b0669946-896b-4cdf-a478-a60afd5c18a5-20&
  redirect_uri=https%3A%2F%2Fauth.eid.gedas.dev%2Fsignin-tara&
  response_type=code&
  scope=openid&
  nonce=CWWLeSzn5tyu3XCSUTIz_BQJgnFxu7US&
  state=J5BpaPNynnbhZCWmDlCZc5QWznVyIfebYGkZ3...
\end{lstlisting}

Before redirecting the user to the {authorize} endpoint, it is important to bind the nonce and the state to the user agent session. We accomplish this by attaching an encrypted cookie to the response which the user agent will save before gets redirected.

\subparagraph{Authorize and Second log-in}

When the user agent redirects the user to the eeID service authentication page, they can chose any option for authentication. This process is not relevant to the thesis.

\subparagraph{Callback: verify state}

After the user finishes authentication with the eeID service, they are redirected to the redirect\_url defined in the request with particular query parameters (see listing \ref{lst:eeid-authorize-callback}). Note the inclusion of nonce, as this value should not be here \cite{okta-oidc-spec}, and we will ignore it for the rest of the section (see Discovered Weaknesses).

\begin{lstlisting}[caption={The eeID service authorize redirect response}, label={lst:eeid-authorize-callback}]
  GET https://auth.eid.gedas.dev/signin-tara?
  
  code=OC-106-2hUkp91Z2acDYJF7PUFjDoTJKkHncVYl&
  nonce=CWWLeSzn5tyu3XCSUTIz_BQJgnFxu7US&
  state=J5BpaPNynnbhZCWmDlCZc5QWznVyIfebYGkZ3...
\end{lstlisting}

The first step the server has to do is to verify if the state received in the callback matches the one stored in the user agent session. If it does not, it was a possible CSRF attack, and the process should end here.

\subparagraph{Callback: acquire token}

Once the authorization server that the state matches the user agent session, it is safe to exchange the received code for an identity token. See listing \ref{lst:eeid-token} for a request example.

\begin{lstlisting}[caption={The eeID service token request}, label={lst:eeid-token}]
  POST /oidc/token HTTP/1.1
  Host: tara.ria.ee
  Content-Type: application/x-www-form-urlencoded
  Authorization: Basic b2lkYy1iMDY2OTk0Ni04OTZiLTRjZGYtYTQ3OC1hN-jBhZmQ1YzE4YTUtMjA6aHR0cHM6Ly95b3V0dS5iZS9kUXc0dzlXZ1hjUQ==

  grant_type=authorization_code&
  code=OC-106-2hUkp91Z2acDYJF7PUFjDoTJKkHncVYl&
  redirect_uri=https%3A%2F%2Fauth.eid.gedas.dev%2Fsignin-tara
\end{lstlisting}

The inclusion of redirect\_uri here may be confusing. It is required as per the OAuth2 spec (section 4.1.3) \cite{rfc6749} and prevents open redirection attacks when using wildcards. The eeID service does not appear to allow them, so the inclusion of this value is redundant; however, if it were excluded, the protocol would no longer be OpenID Connect compliant.

\subparagraph{Callback: verify token}

In the unlikely event the token endpoint request failed, it could mean a sophisticated replay attack could have taken place. If an access token was already issued for that code, it must be immediately revoked. Another way for the request to fail would be if the client or user agent took too long to be redirected. If the token endpoint returns a faulty result, the authentication process should stop.

If the token endpoint returns the identity token successfully, the user should validate its authenticity. If the nonce parameter was used in the first request, the server should verify that nonce in the user agent session matches the one in the id\_token. The rest of the verification should be done as described in the TARA documentation \cite{tara-technical}.

\TODO{I have no clue about the benefit of performing additional verification. The token was received within a secure backchannel, and the nonce matches, meaning the user created the request. If the server makes the user agent session in a way so that no one other than the server itself can tamper, why bother verifying the rest?}

\subparagraph{Issue access token}

After the server verifies the identity token, issue a new access token with the necessary information from the identity token. Most common solution would be to create a new cookie and attach it to the response.


\subsubsection{Discovered Weaknesses}

\paragraph{Incorrect implementation of at\_hash}

In the TARA Technical Specification \cite{tara-technical}, the identity token has at\_hash value that is not according to the OIDC spec \cite{oidc}.

When looking at the id token response, it has a property at\_hash with the value of {X0MVjwrmMQs/IBzfU2osvw==}. This value is supposed to be base64url encoded. Instead, it is a regular base64 string. The Demo REST Client example provided by the same authors \cite{tara-demorest} correctly converts the base64 value into the base64url encoded value, which leads us to believe that there is a mistake in the documentation and or implementation. If it was following the specifications of the TARA documentation and not OIDC spec, it should have no reason to do so.

The eeID service follows the TARA documentation, and because of that, the at\_hash uses base64. An issue arises when the using OpenID Connect libraries (see listing \ref{lst:ms-oidc-at-hash}).

\begin{lstlisting}[caption={Microsoft.IdentityModel.Protocols.OpenIdConnect fails to validate at\_hash}, label={lst:ms-oidc-at-hash}]
  IDX21348: Validating the 'at_hash' failed, see inner exception.
  IDX21300: The hash claim: 'UtsKV8+hA/bB0EE/xR9cCQ==' in the id_token did not validate with against: 'AT-95-VU6Y2LZjrNrVCdhlEaCxG6Gpzt0RsE-Z', algorithm: 'RS256'.
\end{lstlisting}

If we compute the hash manually, we see precisely why the verification failure happens (see listing \ref{lst:athash-manual}). The implementation expects a different string than was provided. The same transcoding behavior is seen on the TARA Demo Client \cite{tara-demorest}.

\begin{lstlisting}[caption={Verifying at\_hash manually}, label={lst:athash-manual}, language={bash}]
  user@localhost:~$ access_token="AT-95-VU6Y2LZjrNrVCdhlEaCxG6Gpzt0RsE-Z"
  user@localhost:~$ echo -n $access_token | openssl dgst -binary -sha256 | head -c 16 | base64
  UtsKV8+hA/bB0EE/xR9cCQ==
  user@localhost:~$ echo -n $access_token | openssl dgst -binary -sha256 | head -c 16 | base64 | tr '/+' '_-' | tr -d '='
  UtsKV8-hA_bB0EE_xR9cCQ
\end{lstlisting}

The implication of this discovery means that all working clients who use eeID have incorrect OpenID connect implementation. This issue affects only those who use the correct OpenID Connect implementation libraries.

\paragraph{Confusing state and nonce behavior}

Nowhere in the OpenID Connect specification mentions that state should be transferred over to the id\_token. TARA confused the purposes of state and nonce properties, extended the behavior to cover each other, and, by extension, made one of the properties obsolete.

The state property is part of the underlying OAuth2.0 specification, where it is an "opaque value used by the client to maintain state between the request and callback" \cite{rfc6749}. The primary security feature is to prevent CSRF attacks \cite{rfc6749,ietf-oauth-security-topics-19}.

The nonce property is part of the OpenID Connect specification, and its primary purpose is to prevent replay attacks when using implicit or hybrid flows \cite{oidc}. Later, researchers discovered that it also protects against authorization code injection attacks with the code flow. Interestingly, this also protected against CSRF attacks making the state property obsolete. The disadvantage of using {nonce} as a state parameter is that it directly influences the size of the id\_token, which should be kept as small as possible. Reasons for keeping this token as small as possible is that developers could use send them in request headers to their resource servers \cite{rfc7519}. The only issue is that these tokens expire after 40 seconds and cannot be refreshed \cite{tara-technical}, making this approach impractical.

If we look at the data flow diagram, we see that both state and nonce have each other's properties. After the user agent returns to the callback URL, both {nonce} and {state} are returned when only {state} is required. After the company's authentication server establishes a backchannel and redeems the code for an id\_token, this token again contains both {nonce} and {state}, when only {nonce} is required.

In the security analysis performed last year, the author suggested removing the nonce parameter from the protocol \cite{tara-security-arnis}. We disagree with this approach and would suggest removing the state parameter from the id\_token response. Removing the nonce parameter and having no support for PKCE would break OIDC compliant libraries' ability to mitigate authorization code injection attacks.

\paragraph{Wrong claims in the OpenID Connect discovery endpoint} The discovery endpoint provides all information about possible requests and responses. Data listed there does not match the documentation. For example, in the discovery endpoint for eeID (\url{https://auth.eeid.ee/oidc/.well-known/openid-configuration}), claims like gender are present, even though this claim can never appear. On the flip side, claim profile\_attributes, as described in the documentation is missing from the discovery document.

\begin{figure}
  \centering
  \begin{sequencediagram}
    \newthread{A}{User Agent}{}
    \newinst[3]{B}{AuthServer}{}
    \newinst[3]{C}{TARA/eeID}{}

    \begin{call}{A}{1. login()}{B}{3xx Redirect}\end{call}
    \begin{call}{A}{2. authorize() [client\_id, redirect\_uri, response\_type, scope, nonce, state]}{C}{Auth Page}\end{call}
    \begin{call}{A}{3. login()}{C}{3xx Redirect + [code, \textcolor{red}{nonce}, state]}\end{call}

    \begin{call}{A}{4. loginCallback()}{B}{Auth token}
      \begin{call}{B}{6. token() [client\_id, client\_secret, redirect\_uri, grant\_type, code]}{C}{id\_token \{ nonce, \textcolor{red}{state}, \dots \}}\end{call}
    \end{call}
  \end{sequencediagram}
  \caption{OIDC code flow used in TARA/eeID}
  \label{fig:oidc-code-flow-wrong}
\end{figure}